import sys
import os.path
import datetime
import io
import fcntl

from selenium.common import exceptions as selexc
from selenium import webdriver
from selenium.webdriver.support.ui import Select
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from selenium.webdriver.common.keys import Keys

from strass.reuse import ReuseTestCase


class Client(object):
    """Client HTTP pour tester fonctionnellement Strass

    Adapteur du pilote Selenium, avec une interface inspirée de Nightwatch.js,
    et quelques paramètres spécifiques à Strass."""

    def __init__(self):
        self.driver = webdriver.Remote(
            os.environ['STRASS_SELENIUM'],
            desired_capabilities=DesiredCapabilities.CHROME,
        )
        self.driver.set_window_size(1120, 768)
        self.driver.implicitly_wait(1)

    def __del__(self):
        if 'driver' in self.__dict__:
            self.driver.quit()

    def get(self, query=None):
        server = os.environ.get('STRASS_TEST_SERVER', 'http://localhost:8000')
        url = server + (query or '/')
        self.driver.get(url)
        return self

    def find(self, selector):
        element = self.driver.find_element_by_css_selector(selector)
        self.scroll(element)
        return element

    def scroll(self, element):
        self.driver.execute_script('arguments[0].scrollIntoView(true);', element)
        return self

    def click(self, selector):
        self.find(selector).click()
        return self

    # Trop galère à trouver. Pour injecter une date, vider le champ,
    # repositionner le curseur, et envoyer les chiffre au format US pourri.
    _date_keys_fmt = Keys.DELETE + Keys.ARROW_LEFT + Keys.ARROW_LEFT + '%m%d%Y'

    def fill(self, selector, value):
        if isinstance(value, datetime.date):
            self.fill(selector + ' input.date', value.strftime(self._date_keys_fmt))
        else:
            control = self.find(selector)
            try:
                control.clear()
            except selexc.InvalidElementStateException:
                # On doit tenter de nettoyer un input[type=date|file]. On zap.
                pass
            control.send_keys(value)
        return self

    def select(self, selector, value):
        Select(self.find(selector)).select_by_value(value)
        return self

    def submit(self, selector='#document button[type=submit]'):
        return self.click(selector)

    def close(self):
        self.driver.close()
        if self.driver.window_handles:
            self.driver.switch_to.window(self.driver.window_handles[0])
        self.driver.set_window_size(1120, 550)
        return self

    def screenshot(self, filename):
        self.driver.get_screenshot_as_file(filename)
        sys.stderr.write("Capture d'écran enregistrée dans %r\n" % (filename,))
        return self

    def save(self, filename):
        with open(filename, 'w') as fo:
            fo.write(self.driver.page_source)
        sys.stderr.write("HTML enregistré dans %r\n" % (filename,))
        return self

    def __getattr__(self, name):
        return getattr(self.driver, name)


class LazyClient(object):
    _real = None

    def __init__(self):
        self.__class__._real = None

    def __getattr__(self, name):
        if not self._real:
            self.__class__._real = Client()
        return getattr(self._real, name)


class ClientTestCase(ReuseTestCase):
    """Classe de test

    Instancie un client strass dans self.client. Sauvegarde une capture d'écran
    et la page HTML courante en cas d'erreur.  La session est permanente pour
    tous les tests de la classe."""

    test_reports = os.environ['STRASS_TEST_REPORTS']
    client = LazyClient()

    @classmethod
    def setUpClass(cls):
        cls.server_log = open(os.environ['SERVER_LOG'], 'r')
        cls.server_log.seek(0, io.SEEK_END)
        fd = cls.server_log.fileno()
        fl = fcntl.fcntl(fd, fcntl.F_GETFL)
        fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)

    def tearDown(self):
        for test_case, exc_info in self._outcome.errors:
            if not exc_info:
                continue

            self.client.screenshot(
                os.path.join(self.test_reports, self.id() + '.png'))
            self.client.save(
                os.path.join(self.test_reports, self.id() + '.html'))
            with open(self.id() + '.log', 'w') as fo:
                sys.stderr.write("Log PHP enregistré dans %r\n" % (fo.name,))
                fo.write(self.server_log.read())

            break

        self.server_log.seek(0, io.SEEK_END)

        super(ClientTestCase, self).tearDown()

    def assertElementFound(self, selector):
        assert self.client.find(selector)
        return self.client

    def assertElementNotFound(self, selector):
        try:
            self.client.find(selector)
            assert False, "Element %s exists" % (selector,)
        except selexc.NoSuchElementException:
            pass
        return self.client

    def assertAttributeEquals(self, expected, selector, attrname):
        element = self.client.find(selector)
        real_value = element.get_attribute(attrname)
        self.assertEqual(expected, real_value)

    def fullpath(self, basename):
        directory = os.path.dirname(
            sys.modules[self.__class__.__module__].__file__)
        fullpath = os.path.join(directory, basename)

        assert os.path.exists(fullpath), \
            "File %s does not exists" % (fullpath,)

        return fullpath
