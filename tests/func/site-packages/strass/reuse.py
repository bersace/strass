import contextlib
import os
import unittest
import pickle

REUSE_STATE = {}


def run_always(callable_):
    callable_.run_always = True
    return callable_


class ReuseTestCase(unittest.TestCase):
    # Pousse l'état du test dans l'état global, pour sauter le test plus tard
    # si besoin.
    def setUp(self):
        super(ReuseTestCase, self).setUp()

        if REUSE_STATE.get(self.id(), False):
            self.skipTest('OK')

    def tearDown(self):
        run_always = getattr(
            getattr(self, self._testMethodName),
            'run_always', False)

        if not run_always:
            REUSE_STATE[self.id()] = not [
                (testcase, exc_info)
                for testcase, exc_info in self._outcome.errors
                if testcase is self and exc_info]

        super(ReuseTestCase, self).tearDown()


class ReuseProgram(unittest.TestProgram):
    # Charge et sauvegarde l'état des tests pour qu'ils puissent déterminer
    # s'il doivent jouer ou non.

    @contextlib.contextmanager
    def reuse_state(self):
        if os.path.exists('.reuse-state'):
            with open('.reuse-state', 'rb') as fo:
                REUSE_STATE.update(pickle.load(fo))

        try:
            yield
        finally:
            try:
                with open('.reuse-state', 'wb') as fo:
                    pickle.dump(REUSE_STATE, fo)
            except Exception:
                os.unlink('.reuse-state')
                raise

    def runTests(self):
        with self.reuse_state():
            return super(ReuseProgram, self).runTests()


main = ReuseProgram
