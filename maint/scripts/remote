#!/usr/bin/python
# -*- coding: utf-8 -*-

import sys
import os.path
import logging
import argparse
from ftplib import FTP, Error as FTPError
from ConfigParser import RawConfigParser
from datetime import datetime
import fnmatch
from getpass import getpass
import subprocess
from collections import OrderedDict


log = logging.getLogger('strass')

class Script(object):
    parser = argparse.ArgumentParser(
        description=u"Gestionnaire de site strass")
    parser.set_defaults(loglevel=logging.INFO)
    parser.add_argument(
        '-d', '--debug',
        action='store_true', dest='debug')
    parser.add_argument(
        '-v', '--verbose',
        action='store_const', dest='loglevel', const=logging.DEBUG)
    parser.add_argument(
        '-q', '--quiet',
        action='store_const', dest='loglevel', const=logging.CRITICAL)
    parser.add_argument(
        '-c', '--config', default='maint/strass.conf', metavar='FILE')
    parser.add_argument(
        '-p', '--production', help=u'Envoi sur le site en production',
        action='store_true', dest='production')

    subparsers = parser.add_subparsers(metavar='ACTION', help=u'Opération avec le site distant')

    def __call__(self):
        args = self.parser.parse_args()
        format = "%(asctime)s %(levelname)-8s %(name)s: %(message)s" if args.loglevel is logging.DEBUG else "%(levelname)-8s: %(message)s"
        logging.basicConfig(level=args.loglevel, format=format)

        try:
            config = RawConfigParser()
            if os.path.exists(args.config):
                with open(args.config) as f:
                    config.readfp(f, args.config)

            return args.action(args, config)
        except Exception, e:
            log.exception(e)
            log.debug("%r", e)
            log.error("%s", e)
            if args.debug:
                import pdb; pdb.post_mortem()
            return 1


def command(cls):
    parser = Script.subparsers.add_parser(cls.__name__)
    parser.set_defaults(action=cls(parser))
    return cls


class FileType(object):
    def __init__(self, repr_):
        self.repr_ = repr_


    def __repr__(self):
        return self.repr_


class FTPOperation(object):
    def __init__(self, path):
        self.path = path


    def __repr__(self):
        return '%s %s' % (self.__class__.__name__, self.path)


    def __cmp__(self, other):
        return cmp(self.__class__, other.__class__) * cmp(self.path, other.path)


    def __eq__(self, other):
        return self.__class__ is other.__class__ and self.path == other.path


    def __hash__(self):
        return hash((self.__class__.__name__, self.path))


class MKD(FTPOperation):
    def __call__(self, client):
        try:
            client.mkd(self.path)
        except FTPError, e:
            # Existe déjà
            if e.message[:3] != '550':
                raise


class STOR(FTPOperation):
    def __call__(self, client):
        client.storbinary('STOR ' + self.path, open(self.path))


class RETR(FTPOperation):
    def __call__(self, client):
        f = open(self.path, 'wb')
        client.retrbinary('RETR %s' % self.path, f.write)


class RMD(FTPOperation):
    def __call__(self, client):
        client.rmd(self.path)


class DELE(FTPOperation):
    def __call__(self, client):
        client.delete(self.path)


class CHMOD(FTPOperation):
    def __init__(self, mode, path):
        super(CHMOD, self).__init__(path)
        self.mode = mode


    def __call__(self, client):
        client.sendcmd('SITE CHMOD %o %s' % (self.mode, self.path))


class FTPEntry(object):
    log = logging.getLogger('strass.ftp')
    exclude = ['.gitignore', '*~', 'zend_cache*', '*.xcf', '*.scss', 'README', 'LICENSE', 'local']

    TYPE_UNKNOWN = FileType('Inconnu')
    TYPE_FILE = FileType('Fichier')
    TYPE_DIR = FileType('Dossier')


    def __init__(self, client, parent, fullpath, type_=None):
        self.client = client
        self.path = os.path.normpath(fullpath)
        self.name = os.path.basename(self.path)
        self.parent = parent
        self._children = None
        self._type = type_
        self._localmtime = None
        self._localsize = None
        self._remotemtime = None
        self._remotesize = None
        self._remoteexists = None


    def __repr__(self):
        return "%s %s" % (self.type_, self.path,)


    def __iter__(self):
        if self.type_ is self.TYPE_FILE:
            raise ValueError("Impossible de lister le fichier %s" % self.path)

        if not self._children:
            self._children = OrderedDict()
            # listage local
            if os.path.exists(self.path):
                for name in os.listdir(self.path):
                    entry = self.__class__(self.client, fullpath=os.path.join(self.path, name), parent=self)
                    # On met par défaut à False, car on va tester juste après
                    entry._remoteexists = False
                    self._children[entry.name] = entry

            # listage distant
            if self._remoteexists in (None, True):
                lines = []
                try:
                    self.client.retrlines('LIST -a %s' % self.path, lines.append)
                except FTPError, e:
                    self._remoteexists = False
                else:
                    self._remoteexists = len(lines) > 0

                for line in lines:
                    try:
                        entry = self.__class__.parse(self.client, self, line)
                    except ValueError:
                        continue

                    if entry.name in ('.', '..'):
                        continue

                    remoteentry = entry
                    entry = self._children.setdefault(entry.name, entry)
                    entry._remoteexists = True
                    entry._remotesize = remoteentry._remotesize

        for child in self._children.values():
            yield child


    def __getitem__(self, path):
        if self.isdir():
            list(iter(self))
            path = os.path.normpath(path)
            members = list(path.split(os.sep))
            name = members.pop(0)
            try:
                child = self._children[name]
            except KeyError:
                child = self.__class__(self.client, parent=self, fullpath=os.path.join(self.path, name))
                if len(members):
                    child._type = self.TYPE_DIR
                self._children[name] = child

            if len(members):
                return child[os.path.join(*members)]
            else:
                return child
        elif self.type_ is self.TYPE_FILE:
            raise ValueError("Impossible de lister le fichier %r" % os.path.join(self.path, path))
        else:
            raise KeyError("Fichier %r inexistant" % os.path.join(self.path, path))


    @classmethod
    def parse(cls, client, parent, line):
        parts = line.split()
        name = ' '.join(parts[8:])

        if name in ('.', '..'):
            raise ValueError("Fichier ignoré")

        fullpath = os.path.join(parent.path, name)

        if line[0] == 'd':
            type_ = cls.TYPE_DIR
        elif line[0] == '-':
            type_ = cls.TYPE_FILE
        else:
            raise Exception("Type %s inconnu: %s" (line[0], line))

        self = cls(client, fullpath=fullpath, type_=type_, parent=parent)
        self._remoteexists = True
        self._remotesize = int(parts[4])
        return self


    @classmethod
    def isignored(cls, name):
        for pattern in cls.exclude:
            if fnmatch.fnmatch(name, pattern):
                return True
        return False


    @property
    def type_(self):
        if not self._type:
            if os.path.exists(self.path):
                if os.path.isdir(self.path):
                    self._type = self.TYPE_DIR
                else:
                    self._type = self.TYPE_FILE
            else:
                lines = []
                try:
                    self.client.retrlines('LIST -a %s' % self.path, lines.append)
                except FTPError, e:
                    lines = []

                if not lines:
                    self._remoteexists = False
                    self._type = self.TYPE_UNKNOWN
                elif len(lines) == 1: # un dossier a au moins . et ..
                    self._remoteexists = True
                    self._type = self.TYPE_FILE
                else:
                    self._remoteexists = True
                    self._type = self.TYPE_DIR

        return self._type


    @property
    def remoteexists(self):
        if self._remoteexists is None:
            if self.type_ is self.TYPE_FILE:
                lines = []
                self.client.retrlines('LIST -a %s' % self.path, lines.append)
                self._remoteexists = len(lines) > 0
            elif self.type_ is self.TYPE_DIR:
                # On pourrait faire un CWD, mais ça ferait une
                # opération de plus. Donc on liste.
                list(iter(self))

        return self._remoteexists


    def isdir(self):
        return self.type_ is self.TYPE_DIR


    def outdated(self, reverse=False):
        """Teste si la version en ligne est obsolète. L'inverse si reverse est à True"""

        if not self._localsize and os.path.exists(self.path):
            self._localsize = os.stat(self.path).st_size

        # Pour les fichiers de plus de 32k, on test la taille plutôt
        # que la date.
        if self.type_ is self.TYPE_FILE and self._localsize and self._remotesize:
            maxsz = max(self._localsize, self._remotesize)
            # Pour les vignettes, icônes, etc. on réduit le seuil
            image = self.name.endswith('jpeg') or self.name.endswith('jpg') \
                    or self.name.endswith('png') or self.name.endswith('svg') \
                    or self.name.endswith('gif') or self.name.endswith('webp')
            threshold = 0 if image else 32
            if image and self._localsize == self._remotesize:
                return False

        if not self._localmtime:
            if not os.path.exists(self.path):
                return reverse

            try:
                subprocess.check_output([
                    'git', 'ls-files', '--error-unmatch', self.path],
                                        stderr=subprocess.PIPE)
                hasdiff = subprocess.call([
                    'git', 'diff', '--exit-code', '--quiet', 'HEAD', self.path],
                                stderr=subprocess.PIPE)
                assert not hasdiff
            except Exception, e:
                timestamp = os.stat(self.path).st_mtime
            else:
                timestamp = int(subprocess.check_output([
                    'git', 'log', '--max-count=1', '--format=format:%at', self.path]))

            self._localmtime = datetime.fromtimestamp(timestamp)

        if not self._remotemtime:
            if not self.remoteexists:
                return not reverse

            ret = self.client.sendcmd('MDTM %s' % self.path)
            code, data = ret.split(None, 1)
            assert int(code) == 213, ret
            self._remotemtime = datetime.strptime(data, '%Y%m%d%H%M%S')

        if reverse:
            return self._remotemtime > self._localmtime
        else:
            return self._remotemtime < self._localmtime


    def remove(self):
        if not self.remoteexists:
            return

        if self.isdir():
            for child in self:
                for op in child.remove():
                    yield op

            yield RMD(self.path)
        else:
            yield DELE(self.path)


    def localremove(self):
        if not os.path.exists(self.path):
            return

        if self.isdir():
            for child in self:
                for op in child.localremove():
                    yield op

            os.rmdir(self.path)
        else:
            os.remove(self.path)


    def mkdir(self):
        if self.parent:
            for op in self.parent.mkdir():
                yield op

        if not self.remoteexists:
            yield MKD(self.path)
            yield CHMOD(0755, self.path)


    def download(self, clean=False):
        if self.isdir():
            try:
                os.makedirs(self.path, mode=0755)
            except OSError, e:
                pass

            for child in self:
                if self.isignored(child.name):
                    continue

                if clean and not child._remoteexists:
                    child.localremove()
                else:
                    for op in child.download(clean=clean):
                        yield op
        else:
            if self.outdated(reverse=True):
                yield RETR(self.path)


    def upload(self, force=False, clean=False):
        if self.isdir():
            for op in self.mkdir():
                yield op

            for child in self:
                if self.isignored(child.name):
                    continue

                for op in child.upload(force=force, clean=clean):
                    yield op
        else:
            if clean and not os.path.exists(self.path):
                for op in self.remove():
                    yield op
            elif force or not self.remoteexists or self.outdated():
                if self.parent:
                    for op in self.parent.mkdir():
                        yield op
                yield STOR(self.path)
                yield CHMOD(0644, self.path)


    def chmod(self, mode):
        yield CHMOD(mode, self.path)


class FTPLogger(object):
    log = logging.getLogger('strass.ftp')

    def __init__(self, client):
        self.client = client


    def _log(self, cmd, *args):
        self.log.debug(">>> %r", cmd % args)


    def mkd(self, path):
        self._log("MKD %s", path)
        self.client.mkd(path)


    def rmd(self, path):
        self._log("RMD %s", path)
        self.client.rmd(path)


    def delete(self, path):
        self._log("DELE %s", path)
        self.client.delete(path)


    def sendcmd(self, cmd):
        self._log(cmd)
        return self.client.sendcmd(cmd)


    def retrlines(self, cmd, *args, **kwargs):
        self._log(cmd)
        return self.client.retrlines(cmd, *args, **kwargs)


    def retrbinary(self, cmd, *args, **kwargs):
        self._log(cmd)
        return self.client.retrbinary(cmd, *args, **kwargs)


    def storbinary(self, cmd, *args):
        self._log(cmd)
        return self.client.storbinary(cmd, *args)


    def __getattr__(self, name):
        return getattr(self.client, name)


class FTPQueue(OrderedDict):
    log = logging.getLogger('strass.ftp')


    def add(self, op):
        if op not in self:
            self.log.debug("Mise en file de %s", op)
            self[op] = op


class FTPManager(object):
    log = logging.getLogger('strass.ftp')


    def __init__(self):
        self.operations = FTPQueue()


    def connect(self, config, production):
        section = 'production' if production else 'test'
        self.config = config
        client = FTPLogger(FTP())
        hostname = self.config.get(section, 'hostname')
        client.connect(hostname)
        client.login(self.config.get(section, 'username'),
                       self.config.get(section, 'password'))
        client.cwd(self.config.get(section, 'root'))
        self.log.debug(u"Connecté au server de %s : %s", section, hostname)
        self.log.debug(client.getwelcome())

        self.client = client
        self.tree = FTPEntry(client=self.client, parent=None, fullpath='.')


    def __del__(self):
        if not hasattr(self, 'client'):
            return

        self.client.quit()
        self.client.close()


    def upload(self, *pathes):
        for path in pathes:
            entry = self.tree[path]
            for op in entry.upload(force=True):
                self.operations.add(op)


    def download(self, *pathes):
        for path in pathes:
            entry = self.tree[path]
            for op in entry.download():
                self.operations.add(op)


    def mirror(self, *pathes):
        for path in pathes:
            entry = self.tree[path]
            for op in entry.upload(clean=True):
                self.operations.add(op)


    def backup(self, *pathes):
        for path in pathes:
            entry = self.tree[path]
            for op in entry.download(clean=True):
                self.operations.add(op)


    def remove(self, *pathes):
        for path in pathes:
            entry = self.tree[path]
            for op in entry.remove():
                self.operations.add(op)


    def chmod(self, mode, *pathes):
        for path in pathes:
            entry = self.tree[path]
            for op in entry.chmod(mode):
                self.operations.add(op)


    def run(self):
        total = len(self.operations)
        for done, op in enumerate(self.operations):
            try:
                op(self.client)
            except Exception, e:
                self.log.warn(u"Échec de l'opération %s: %s", op, e)
        self.log.info('Transfert terminé')


@command
class config(object):
    """Assistant de configuration des outils de mise en prod"""
    log = logging.getLogger('strass.config')


    def __init__(self, parser):
        pass


    def prompt_config_string(self, config, section, name, label):
        try:
            default = config.get(section, name)
            prompt = "%s [%s] : " % (label, default)
        except Exception, e:
            default = None
            prompt = "%s : " % (label,)
        value = raw_input(prompt)
        if not value:
            if not default:
                raise Exception("Valeur requise")
            value = default

        config.set(section, name, value)
        return value


    def prompt_config_password(self, config, section, name, label):
        try:
            default = config.get(section, name)
            prompt = "%s [%s] : " % (label, 6 * '*')
        except Exception, e:
            default = None
            prompt = "%s : " % (label,)
        value = getpass(prompt)
        if not value:
            if not default:
                raise Exception("Valeur requise")
            value = default

        config.set(section, name, value)
        return value


    def prompt_config(self, config, section):
        while 1:
            print
            print "  Serveur de %s :" % (section,)
            print
            try:
                config.add_section(section)
            except Exception, e:
                pass
            self.prompt_config_string(config, section, 'hostname', "Serveur")
            self.prompt_config_string(config, section, 'username', "Identifiant")
            self.prompt_config_password(config, section, 'password', "Mot de passe")
            self.prompt_config_string(config, section, 'root', "Dossier")

            try:
                FTPManager().connect(config, production=section == 'production')
                break
            except Exception, e:
                self.log.error("Configuration incorrecte ?")
                self.log.error("%s", e)


    def __call__(self, args, config):
        print """

Pour vous assister dans la maintenance de votre site, Strass a besoin
de connaître votre accès FTP.

"""
        try:
            self.prompt_config(config, 'test')
        except EOFError:
                return 1

        # Par défaut, on recopie les valeurs de test dans la prod
        try:
            config.add_section('production')
        except Exception, e:
            pass

        for k in 'hostname', 'username', 'password', 'root':
            if config.has_option('production', k):
                continue
            config.set('production', k, config.get('test', k))

        try:
            self.prompt_config(config, 'production')
        except EOFError:
                return 1

        config.write(open(args.config, 'w'))
        os.chmod(args.config, 0600)
        self.log.info('Strass est prêt !')


@command
class setmaint(object):
    """Met le site distant en maintenance"""
    log = logging.getLogger('strass.maint')


    def __init__(self, parser):
        pass


    def __call__(self, args, config):
        ftp = FTPManager()
        ftp.connect(config, args.production)
        ftp.upload('maintenance.html', 'include/Strass.php', 'index.php')
        ftp.run()


@command
class unsetmaint(object):
    """Met le site distant en production"""
    log = logging.getLogger('strass.maint')


    def __init__(self, parser):
        pass


    def __call__(self, args, config):
        ftp = FTPManager()
        ftp.connect(config, args.production)
        ftp.remove('maintenance.html')
        ftp.run()


@command
class backup1(object):
    """Télécharge un site strass v1"""
    log = logging.getLogger('strass.backup')

    def __init__(self, parser):
        pass


    def __call__(self, args, config):
        ftp = FTPManager()
        ftp.connect(config, args.production)
        self.log.info("Préparation de la sauvegarde")
        ftp.download('resources/styles', 'config/', 'data/')
        self.log.info("Démarrage de la sauvegarde")
        ftp.run()


@command
class backup(object):
    """Télécharge un site strass"""
    log = logging.getLogger('strass.backup')

    def __init__(self, parser):
        pass


    def __call__(self, args, config):
        ftp = FTPManager()
        ftp.connect(config, args.production)
        self.log.info("Préparation de la sauvegarde")
        ftp.backup('private/',
                   # tout data sauf scripts, install et styles
                   'data/avatars/', 'data/documents/', 'data/journaux/', 'data/photos/', 'data/unites/')
        self.log.info("Démarrage de la sauvegarde")
        ftp.run()


@command
class upgrade(object):
    """Met à jour le code d'un site strass v2 depuis le dossier courant."""
    log = logging.getLogger('strass.upgrade')


    def __init__(self, parser):
        pass


    def __call__(self, args, config):
        ftp = FTPManager()
        ftp.connect(config, args.production)
        self.log.info("Préparation de la mise à jour")
        ftp.mirror('.htaccess', 'index.php', '500.html',
                   'include/Strass/', 'include/Wtk/', 'data/styles/', 'include/templates/',
                   'data/scripts/wtk/')
        self.log.info("Démarrage de la mise à jour")
        ftp.run()


@command
class mirror(object):
    """Envoie une mise-à-jour complète du site."""
    log = logging.getLogger('strass.mirror')


    def __init__(self, parser):
        parser.add_argument(
            '-p', '--partial',
            action='store_true', dest='partial',
            help="Ne pas Envoyer les photos, les dépendances, etc.")


    def __call__(self, args, config):
        ftp = FTPManager()
        ftp.connect(config, args.production)
        self.log.info("Préparation de la mise à jour")
        ftp.mirror('.htaccess', 'index.php', '500.html', 'private/')
        ftp.chmod(0700, 'private/', 'include/')
        if args.partial:
            ftp.mirror('include/Strass/', 'include/Wtk/', 'include/templates/',
                       'data/scripts/wtk/', 'data/styles/')
        else:
            ftp.mirror('include/', 'data/')
        # nettoyage v1
        ftp.remove('resources/', 'config/', 'cache/')
        self.log.info("Démarrage de la mise à jour")
        ftp.run()


main = Script()
sys.exit(main())
