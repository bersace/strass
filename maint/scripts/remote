#!/usr/bin/python
# -*- coding: utf-8 -*-

import sys
import os.path
import logging
import argparse
from ftplib import FTP
from ConfigParser import RawConfigParser
from datetime import datetime
import fnmatch
from getpass import getpass


log = logging.getLogger('strass')

class Script(object):
    parser = argparse.ArgumentParser(
        description=u"Gestionnaire de site strass")
    parser.set_defaults(loglevel=logging.INFO)
    parser.add_argument(
        '-v', '--verbose',
        action='store_const', dest='loglevel', const=logging.DEBUG)
    parser.add_argument(
        '-q', '--quiet',
        action='store_const', dest='loglevel', const=logging.CRITICAL)
    parser.add_argument(
        '-c', '--config', default='maint/strass.conf', metavar='FILE')

    subparsers = parser.add_subparsers(metavar='ACTION', help=u'Opération avec le site distant')

    def __call__(self):
        args = self.parser.parse_args()
        format = "%(asctime)s %(levelname)-8s %(name)s: %(message)s" if args.loglevel is logging.DEBUG else "%(levelname)-8s: %(message)s"
        logging.basicConfig(level=args.loglevel, format=format)

        try:
            config = RawConfigParser()
            if os.path.exists(args.config):
                with open(args.config) as f:
                    config.readfp(f, args.config)

            return args.action(args, config)
        except Exception, e:
            log.exception(e)
            log.debug("%r", e)
            log.error("%s", e)
            return 1


def command(cls):
    parser = Script.subparsers.add_parser(cls.__name__)
    parser.set_defaults(action=cls(parser))
    return cls


class FTPEntry(object):
    log = logging.getLogger('strass.ftp')


    def __init__(self, ftp):
        self.ftp = ftp


    def list_(self):
        entries = []
        self.log.debug("Listage de %s", self.path)
        self.ftp.retrlines('LIST -a %s' % self.path, entries.append)
        return sorted([self.parse(e, self.path, ftp=self.ftp) for e in entries])[2:]


    def remove(self):
        if self.type_ == 'd':
            for entry in self.list_():
                entry.remove()
            self.log.debug("Suppression de %s", self.path)
            self.ftp.rmd(self.path)
        else:
            self.log.debug("Suppression de %s", self.path)
            self.ftp.delete(self.path)


    @classmethod
    def parse(cls, line, parent, ftp):
        self = cls(ftp)
        self.type_ = line[0]
        self.name = line.split(None, 8)[-1]
        self.path = os.path.join(parent, self.name)
        return self


    def __repr__(self):
        return "%s %s" % (self.type_, self.name)


    def __cmp__(self, other):
        """Très sale, on met . et .. en premier, systématiquement. Sinon tri alphabêtement"""
        a = self.name
        b = other.name
        if a == '.':
            return -1
        elif a == '..':
            return 1 if b == '.' else -1
        elif b == '.':
            return 1
        elif b == '..':
            return -1 if a == '.' else 1
        return 0


class FTPHelper(object):
    """Implémente des opérations de haut niveaux au dessus de ce foutu protocole FTP"""

    log = logging.getLogger('strass.ftp')
    exclude = ['*~', 'zend_cache*', '*.xcf', '*.scss', 'README', 'LICENSE']


    def __init__(self, config):
        self.config = config
        self.ftp = FTP()


    def __del__(self):
        self.ftp.quit()
        self.ftp.close()


    def connect(self):
        self.ftp.connect(self.config.get('remote', 'hostname'))
        self.ftp.login(self.config.get('remote', 'username'),
                       self.config.get('remote', 'password'))
        self.ftp.cwd(self.config.get('remote', 'root'))
        self.log.debug(u"Connecté à %s", self.config.get('remote', 'hostname'))
        self.log.debug(self.ftp.getwelcome())


    def exists(self, path):
        entries = []
        self.ftp.retrlines('LIST -a %s' % path, entries.append)
        return len(entries) > 0


    def isdir(self, path):
        """Retourne la liste des entrées si c'est un dossier, False sinon"""
        entries = []
        self.log.debug("Listage de %s", path)
        self.ftp.retrlines('LIST -a %s' % path, entries.append)
        if not entries:
            return False

        entries = sorted([FTPEntry.parse(e, path, ftp=self.ftp) for e in entries])
        if entries[0].name == '.':
            return entries[2:]
        else:
            return False


    def mtime(self, path):
        """Retourne la date de dernière modification d'un fichier distant"""
        try:
            ret = self.ftp.sendcmd('MDTM %s' % path)
        except Exception, e:
            raise Exception(u"Echec de MDTM sur %s: %s" % (path, str(e)))
        code, data = ret.split(None, 1)
        assert int(code) == 213, ret
        return datetime.strptime(data, '%Y%m%d%H%M%S')


    def _exclude_names(self, names):
        for pattern in self.exclude:
            for name in names[:]:
                if not fnmatch.fnmatch(name, pattern):
                    continue
                names.remove(name)
        return sorted(names)


    def mirror(self, path):
        """Recopie un chemin local à distance, en nettoyant le dossier distant de fichiers supprimé"""
        self.put(path)
        self.clean(path)


    def put(self, path, force=False):
        """Copie un dossier vers le serveur. Vérifie la date de dernière modification pour économiser."""

        if os.path.isdir(path):
            if not self.exists(path):
                self.ftp.mkd(path)
            entries = self._exclude_names(os.listdir(path))
            for entry in entries:
                self.put(os.path.join(path, entry))
        else:
            if not force:
                try:
                    rmtime = self.mtime(path)
                    lmtime = datetime.fromtimestamp(os.stat(path).st_mtime)
                    if rmtime > lmtime:
                        self.log.debug('%s à jour', path)
                        return
                except Exception, e:
                    pass
            self.log.debug("Envoi de %s", path)
            self.ftp.storbinary('STOR ' + path, open(path))


    def remove(self, path):
        """Supprime un fichier ou un dossier, récursivement"""
        entries = self.isdir(path)
        if entries is not False:
            for entry in entries:
                entry.remove()
            self.log.debug("Suppression de %s", path)
            self.ftp.rmd(path)
        elif self.exists(path):
            self.log.debug("Suppression de %s", path)
            self.ftp.delete(path)


    def clean(self, path):
        """Nettoye un dossier distant de fichiers supprimés localement"""
        try:
            local_entries = self._exclude_names(os.listdir(path))
        except OSError, e:
            local_entries = []
        remote_entries = self.isdir(path)
        for entry in remote_entries:
            if not self._exclude_names([entry.name]):
                continue
            childpath = os.path.join(path, entry.name)

            if entry.type_ == 'd':
                self.clean(childpath)

            if entry.name not in local_entries:
                entry.remove()


    def getfile(self, path):
        parent = os.path.dirname(path)
        if parent and not os.path.exists(parent):
            os.makedirs(parent)

        if os.path.exists(path):
            remote_last_mod = self.mtime(path)
            local_last_mod = datetime.fromtimestamp(os.stat(path).st_mtime)
            if local_last_mod > remote_last_mod:
                self.log.debug('%s à jour', path)
                return

        self.log.debug(u"Réception de %s", path.decode('utf-8'))
        f = open(path, 'wb')
        self.ftp.retrbinary('RETR %s' % path, f.write)


    def get(self, path):
        """Copie un dossier local depuis un dossier distant"""
        entries = self.isdir(path)
        if entries is False:
            self.getfile(path)
        else:
            for entry in entries:
                childpath = path + '/' + entry.name
                if entry.type_ == 'd':
                    self.get(childpath)
                elif entry.type_ == '-':
                    # on appelle directement getfile, plutôt que de
                    # faire une récursion qui coûterait un LIST
                    self.getfile(childpath)
                else:
                    self.log.info('Ignore %s', childpath)


@command
class config(object):
    """Assistant de configuration des outils de mise en prod"""
    log = logging.getLogger('strass.config')


    def __init__(self, parser):
        pass


    def prompt_config(self, config, name, label):
        try:
            default = config.get('remote', name)
            prompt = "%s [%s] : " % (label, default)
        except Exception, e:
            prompt = "%s : " % (label,)
        value = raw_input(prompt)
        if not value:
            value = default

        config.set('remote', name, value)
        return value


    def prompt_config_password(self, config, name, label):
        try:
            default = config.get('remote', name)
            prompt = "%s [%s] : " % (label, 6 * '*')
        except Exception, e:
            prompt = "%s : " % (label,)
        value = getpass(prompt)
        if not value:
            value = default

        config.set('remote', name, value)
        return value


    def __call__(self, args, config):
        print """

Pour vous assister dans la maintenance de votre site, Strass a besoin
de connaître votre accès FTP.

"""
        try:
            config.add_section('remote')
        except Exception, e:
            pass
        self.prompt_config(config, 'hostname', "Serveur")
        self.prompt_config(config, 'username', "Identifiant")
        self.prompt_config_password(config, 'password', "Mot de passe")
        self.prompt_config(config, 'root', "Dossier")

        ftp = FTPHelper(config)
        ftp.connect()

        config.write(open(args.config, 'w'))
        os.chmod(args.config, 0600)
        self.log.info('Strass est prêt !')


@command
class setmaint(object):
    """Met le site distant en maintenance"""
    log = logging.getLogger('strass.maint')


    def __init__(self, parser):
        pass


    def __call__(self, args, config):
        ftp = FTPHelper(config)
        ftp.connect()
        ftp.put('maintenance.html', force=True)
        ftp.put('include/Strass/Version.php', force=True)
        ftp.put('index.php', force=True)


@command
class unsetmaint(object):
    """Met le site distant en production"""
    log = logging.getLogger('strass.maint')


    def __init__(self, parser):
        pass


    def __call__(self, args, config):
        ftp = FTPHelper(config)
        ftp.connect()
        ftp.remove('maintenance.html')


@command
class backup1(object):
    """Télécharge un site strass v1"""
    log = logging.getLogger('strass.backup')

    def __init__(self, parser):
        pass


    def __call__(self, args, config):
        ftp = FTPHelper(config)
        ftp.connect()
        ftp.get('resources/styles')
        ftp.get('config')
        ftp.get('data')


@command
class upgrade(object):
    """Met à jour un site strass v2 depuis le dossier courant."""
    log = logging.getLogger('strass.upgrade')


    def __init__(self, parser):
        pass


    def __call__(self, args, config):
        ftp = FTPHelper(config)
        ftp.connect()
        ftp.mirror('private/')
        ftp.mirror('data/')
        ftp.mirror('include/')
        ftp.put('index.php')
        # nettoyage v1
        ftp.remove('resources/')
        ftp.remove('config/')
        ftp.remove('cache/')


main = Script()
sys.exit(main())
