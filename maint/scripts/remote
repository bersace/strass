#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import os.path
import logging.config
import argparse
from ftplib import FTP, Error as FTPError, error_perm
from ConfigParser import RawConfigParser
from datetime import datetime
import fnmatch
from getpass import getpass
import subprocess
from collections import OrderedDict


# http://stackoverflow.com/a/16955098
TRACE = logging.DEBUG - 10
logging.addLevelName(TRACE, 'TRACE')
def trace(self, message, *args, **kwargs):
    return self.log(TRACE, message, *args, **kwargs)
logging.Logger.trace = trace


class ColorFormatter(logging.Formatter):
    BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE = range(8)

    # The background is set with 40 plus the number of the color, and the
    # foreground with 30

    RESET_SEQ = "\033[0m"
    COLOR_SEQ = "\033[1;%dm"
    BOLD_SEQ = "\033[1m"

    COLORS = {
        'TRACE': BLACK,
        'DEBUG': BLACK,
        'INFO': GREEN,
        'WARNING': YELLOW,
        'ERROR': RED,
        'CRITICAL': RED,
    }

    def format(self, record):
        payload = logging.Formatter.format(self, record)

        levelname = record.levelname
        if levelname in self.COLORS:
            set_seq = self.COLOR_SEQ % (30 + self.COLORS[levelname])
            payload = set_seq + payload + self.RESET_SEQ

        return payload


log = logging.getLogger('strass')


class Script(object):
    parser = argparse.ArgumentParser(
        description=u"Gestionnaire de site strass")
    parser.set_defaults(loglevel=logging.INFO)
    parser.add_argument(
        '-d', '--debug',
        action='store_true', dest='debug')
    parser.add_argument(
        '-v', '--verbose',
        action='store_const', dest='loglevel', const=logging.DEBUG)
    parser.add_argument(
        '-q', '--quiet',
        action='store_const', dest='loglevel', const=logging.CRITICAL)
    parser.add_argument(
        '-t', '--trace',
        action='store_const', dest='loglevel', const=TRACE)
    parser.add_argument(
        '-c', '--config', default='strass.conf', metavar='FILE')
    parser.add_argument(
        '-r', '--root', metavar='ROOT',
        default=os.environ.get('STRASS_ROOT', 'htdocs'))

    subparsers = parser.add_subparsers(metavar='ACTION', help=u'Opération avec le site distant')

    def __call__(self):
        args = self.parser.parse_args()

        format_ = "%(asctime)s %(name)s: %(message)s" if args.loglevel < logging.INFO else "%(message)s"
        formatter = ColorFormatter(format_, '%H:%M:%S')
        handler = logging.StreamHandler(sys.stderr)
        handler.setFormatter(formatter)
        logger = logging.getLogger()
        logger.addHandler(handler)
        logger.setLevel(args.loglevel)

        try:
            config = RawConfigParser()
            if os.path.exists(args.config):
                with open(args.config) as f:
                    config.readfp(f, args.config)
        except Exception, e:
            log.exception(e)
            log.debug("%r", e)
            log.error("%s", e)
            if args.debug:
                import pdb; pdb.post_mortem()
            return 1
        try:
            args.saas = config.getboolean('remote', 'saas')
        except Exception, e:
            args.saas = None

        try:
            return args.action(args, config)
        except (FTPError, error_perm), e:
            log.error("%s", e)
        except Exception, e:
            if args.debug:
                import pdb; pdb.post_mortem()
            return 1


def command(cls):
    parser = Script.subparsers.add_parser(cls.__name__)
    parser.set_defaults(action=cls(parser))
    return cls


class FileType(object):
    def __init__(self, repr_):
        self.repr_ = repr_


    def __repr__(self):
        return self.repr_


class FTPOperation(object):
    def __init__(self, entry):
        self.path = entry.path
        self.localpath = entry.localpath


    def __repr__(self):
        return '%s %r' % (self.__class__.__name__, self.path)


    def __cmp__(self, other):
        return cmp(self.__class__, other.__class__) * cmp(self.path, other.path)


    def __eq__(self, other):
        return self.__class__ is other.__class__ and self.path == other.path


    def __hash__(self):
        return hash((self.__class__.__name__, self.path))


class MKD(FTPOperation):
    def __call__(self, client):
        try:
            client.mkd(self.path)
        except FTPError, e:
            # Existe déjà
            if e.message[:3] != '550':
                raise


class STOR(FTPOperation):
    def __call__(self, client):
        client.storbinary('STOR ' + self.path, open(self.localpath))


class RETR(FTPOperation):
    def __call__(self, client):
        f = open(self.localpath, 'wb')
        client.retrbinary('RETR %s' % self.path, f.write)


class RMD(FTPOperation):
    def __call__(self, client):
        client.rmd(self.path)


class DELE(FTPOperation):
    def __call__(self, client):
        client.delete(self.path)


class CHMOD(FTPOperation):
    def __init__(self, mode, entry):
        super(CHMOD, self).__init__(entry)
        self.mode = mode


    def __call__(self, client):
        client.sendcmd('SITE CHMOD %o %s' % (self.mode, self.path))


class FTPEntry(object):
    log = logging.getLogger('strass.ftp')
    exclude = [
        '.*', '*~', 'zend_cache*', '*.xcf', '*.scss', 'README',
        'LICENSE', 'local', 'strass*.conf',
    ]
    local_files = ['data*', 'private*', '*.html', 'google*']

    TYPE_UNKNOWN = FileType('Inconnu')
    TYPE_FILE = FileType('Fichier')
    TYPE_DIR = FileType('Dossier')


    def __init__(self, manager, parent, fullpath, type_=None):
        self.manager = manager
        self.path = os.path.normpath(fullpath)
        self.name = os.path.basename(self.path)
        self.parent = parent
        self._children = None
        self._type = type_
        self._localmtime = None
        self._localsize = None
        self._remotemtime = None
        self._remotesize = None
        self._remoteexists = None
        self._localpath = None
        self.git = ['git', '-C', self.manager.local_root]


    def __repr__(self):
        return "%s %r" % (self.type_, self.path,)


    def __iter__(self):
        if self.type_ is self.TYPE_FILE:
            raise ValueError("Impossible de lister le fichier %s" % self.path)

        if not self._children:
            self._children = OrderedDict()
            # listage local
            if os.path.exists(self.localpath):
                for name in os.listdir(self.localpath):
                    entry = self.__class__(
                        self.manager, fullpath=os.path.join(self.path, name),
                        parent=self)
                    # On met par défaut à False, car on va tester juste après
                    entry._remoteexists = False
                    self._children[entry.name] = entry

            # listage distant
            if self._remoteexists in (None, True):
                lines = []
                try:
                    self.manager.client.retrlines('LIST -a %s' % self.path, lines.append)
                except FTPError, e:
                    self._remoteexists = False
                else:
                    self._remoteexists = len(lines) > 0

                for line in lines:
                    try:
                        entry = self.__class__.parse(self.manager, self, line)
                    except ValueError:
                        continue

                    if entry.name in ('.', '..'):
                        continue

                    remoteentry = entry
                    entry = self._children.setdefault(entry.name, entry)
                    entry._remoteexists = True
                    entry._remotesize = remoteentry._remotesize

        for child in self._children.values():
            yield child


    def __getitem__(self, path):
        if self.isdir():
            list(iter(self))
            path = os.path.normpath(path)
            members = list(path.split(os.sep))
            name = members.pop(0)
            try:
                child = self._children[name]
            except KeyError:
                child = self.__class__(
                    self.manager, parent=self, fullpath=os.path.join(self.path, name))
                if len(members):
                    child._type = self.TYPE_DIR
                self._children[name] = child

            if len(members):
                return child[os.path.join(*members)]
            else:
                return child
        elif self.type_ is self.TYPE_FILE:
            raise ValueError("Impossible de lister le fichier %r" % os.path.join(self.path, path))
        else:
            raise KeyError("Fichier %r inexistant" % os.path.join(self.path, path))


    @property
    def localpath(self):
        if not self._localpath:
            for pattern in self.local_files:
                if fnmatch.fnmatch(self.path, pattern):
                    self._localpath = os.path.join(self.manager.local_root, self.path)
                    self.log.trace(
                        u"Le fichier local de %s est %s",
                        repr(self.path), repr(self._localpath))
                    break
            else:
                self._localpath = self.path
        return self._localpath


    @classmethod
    def parse(cls, client, parent, line):
        parts = line.split()
        name = ' '.join(parts[8:])

        if name in ('.', '..'):
            raise ValueError("Fichier ignoré")

        fullpath = os.path.join(parent.path, name)

        if line[0] == 'd':
            type_ = cls.TYPE_DIR
        elif line[0] == '-':
            type_ = cls.TYPE_FILE
        else:
            raise Exception("Type %s inconnu: %s" (line[0], line))

        self = cls(client, fullpath=fullpath, type_=type_, parent=parent)
        self._remoteexists = True
        self._remotesize = int(parts[4])
        return self


    @classmethod
    def isignored(cls, name):
        for pattern in cls.exclude:
            if fnmatch.fnmatch(name, pattern):
                return True
        return False


    @property
    def type_(self):
        if not self._type:
            if os.path.exists(self.localpath):
                if os.path.isdir(self.localpath):
                    self._type = self.TYPE_DIR
                else:
                    self._type = self.TYPE_FILE
            else:
                lines = []
                try:
                    self.manager.client.retrlines('LIST -a %s' % self.path, lines.append)
                except FTPError, e:
                    lines = []

                if not lines:
                    self._remoteexists = False
                    self._type = self.TYPE_UNKNOWN
                elif len(lines) == 1: # un dossier a au moins . et ..
                    self._remoteexists = True
                    self._type = self.TYPE_FILE
                else:
                    self._remoteexists = True
                    self._type = self.TYPE_DIR

        return self._type


    @property
    def remoteexists(self):
        if self._remoteexists is None:
            if self.type_ is self.TYPE_FILE:
                lines = []
                self.manager.client.retrlines('LIST -a %s' % self.path, lines.append)
                self._remoteexists = len(lines) > 0
            elif self.type_ is self.TYPE_DIR:
                # On pourrait faire un CWD, mais ça ferait une
                # opération de plus. Donc on liste.
                list(iter(self))

        return self._remoteexists


    def isdir(self):
        return self.type_ is self.TYPE_DIR


    def outdated(self, reverse=False):
        """Teste si la version en ligne est obsolète. L'inverse si reverse est à True"""

        if not self._localsize and os.path.exists(self.localpath):
            self._localsize = os.stat(self.localpath).st_size

        # Pour les fichiers de plus de 32k, on test la taille plutôt
        # que la date.
        if self.type_ is self.TYPE_FILE and self._localsize and self._remotesize:
            maxsz = max(self._localsize, self._remotesize)
            # Pour les vignettes, icônes, etc. on réduit le seuil
            image = self.name.endswith('jpeg') or self.name.endswith('jpg') \
                    or self.name.endswith('png') or self.name.endswith('svg') \
                    or self.name.endswith('gif') or self.name.endswith('webp')
            threshold = 0 if image else 32
            if image and self._localsize == self._remotesize:
                self.log.trace("%s a la même taille. On ignore.", self)
                return False

        if not self._localmtime:
            if not os.path.exists(self.localpath):
                self.log.trace("%s n'existe pas en local.")
                return reverse

            try:
                subprocess.check_output(
                    self.git + ['ls-files', '--error-unmatch', self.localpath],
                    stderr=subprocess.PIPE)
                self.log.trace(u"Vérifier si %r est versionné", self)
                hasdiff = subprocess.call(
                    self.git + ['diff', '--exit-code', '--quiet', 'HEAD', self.localpath],
                    stderr=subprocess.PIPE)
                self.log.trace(u"Vérifier si %r est modifié localement", self)
                assert not hasdiff, "Local modification"
                commit_date = subprocess.check_output(
                    self.git + ['log', '--max-count=1', '--format=format:%at',
                     self.localpath])
                self.log.trace(u"Demander à git la date de %r", self)
                # Valable pours les fichiers générés : 500.html, maintenance.html, etc.
                assert commit_date, "Not versionned: " + self.localpath
                timestamp = int(commit_date)
            except Exception, e:
                timestamp = os.stat(self.localpath).st_mtime

            self._localmtime = datetime.fromtimestamp(int(timestamp))

        if not self._remotemtime:
            if not self.remoteexists:
                self.log.trace("%s n'existe pas à distance.")
                return not reverse

            ret = self.manager.client.sendcmd('MDTM %s' % self.path)
            code, data = ret.split(None, 1)
            assert int(code) == 213, ret
            self._remotemtime = datetime.strptime(data, '%Y%m%d%H%M%S')

        self.log.trace(
            u"Dates de %s : \n\tDistant : %s\n\tLocal :   %s", self,
            self._remotemtime, self._localmtime)

        if reverse:
            return self._remotemtime > self._localmtime
        else:
            return self._remotemtime < self._localmtime


    def remove(self):
        if not self.remoteexists:
            return

        if self.isdir():
            for child in self:
                for op in child.remove():
                    yield op

            yield RMD(self)
        else:
            yield DELE(self)


    def localremove(self):
        if not os.path.exists(self.localpath):
            return

        if self.isdir():
            for child in self:
                for op in child.localremove():
                    yield op

            os.rmdir(self.localpath)
        else:
            os.remove(self.localpath)


    def mkdir(self):
        if self.parent:
            for op in self.parent.mkdir():
                yield op

        if not self.remoteexists:
            yield MKD(self)
            yield CHMOD(0755, self)


    def download(self, clean=False):
        if self.isdir():
            try:
                os.makedirs(self.localpath, mode=0750)
            except OSError, e:
                pass

            for child in self:
                if self.isignored(child.name):
                    continue

                if clean and not child._remoteexists:
                    child.localremove()
                else:
                    for op in child.download(clean=clean):
                        yield op
        else:
            if self.outdated(reverse=True):
                yield RETR(self)


    def upload(self, force=False, clean=False):
        if self.isdir():
            for op in self.mkdir():
                yield op

            for child in self:
                if self.isignored(child.name):
                    continue

                for op in child.upload(force=force, clean=clean):
                    yield op
        else:
            if clean and not os.path.exists(self.localpath):
                for op in self.remove():
                    yield op
            elif force or not self.remoteexists or self.outdated():
                if self.parent:
                    for op in self.parent.mkdir():
                        yield op
                yield STOR(self)
                yield CHMOD(0644, self)


    def chmod(self, mode):
        yield CHMOD(mode, self)


class FTPLogger(object):
    log = logging.getLogger('strass.ftp')

    def __init__(self, client):
        self.client = client


    def _log(self, cmd, *args):
        self.log.debug(">>> %r", cmd % args)


    def mkd(self, path):
        self._log("MKD %s", path)
        self.client.mkd(path)


    def rmd(self, path):
        self._log("RMD %s", path)
        self.client.rmd(path)


    def delete(self, path):
        self._log("DELE %s", path)
        self.client.delete(path)


    def sendcmd(self, cmd):
        self._log(cmd)
        return self.client.sendcmd(cmd)


    def retrlines(self, cmd, *args, **kwargs):
        self._log(cmd)
        return self.client.retrlines(cmd, *args, **kwargs)


    def retrbinary(self, cmd, *args, **kwargs):
        self._log(cmd)
        return self.client.retrbinary(cmd, *args, **kwargs)


    def storbinary(self, cmd, *args):
        self._log(cmd)
        return self.client.storbinary(cmd, *args)


    def __getattr__(self, name):
        return getattr(self.client, name)


class FTPQueue(OrderedDict):
    log = logging.getLogger('strass.ftp')


    def add(self, op):
        if op not in self:
            self.log.debug("Mise en file de %s", op)
            self[op] = op


class FTPManager(object):
    log = logging.getLogger('strass.ftp')

    def __init__(self, local_root='.'):
        self.operations = FTPQueue()
        self.local_root = local_root


    def connect(self, config):
        section = 'remote'
        self.config = config
        client = FTPLogger(FTP())
        hostname = self.config.get(section, 'hostname')
        self.log.debug(u"Connexion au serveur...")
        client.connect(hostname)
        self.log.debug(u"Authentification...")
        client.login(self.config.get(section, 'username'),
                       self.config.get(section, 'password'))
        self.log.debug(u"Accès au dossier...")
        client.cwd(self.config.get(section, 'root'))
        self.log.debug(u"Connecté au serveur: %s", hostname)
        for line in client.getwelcome().splitlines():
            self.log.debug(line)

        self.client = client
        self.tree = FTPEntry(manager=self, parent=None, fullpath='.')


    def __del__(self):
        if not hasattr(self, 'client'):
            return

        self.client.quit()
        self.client.close()


    def exists(self, path):
        return self.tree[path].remoteexists


    def upload(self, *pathes):
        for path in pathes:
            entry = self.tree[path]
            for op in entry.upload(force=True):
                self.operations.add(op)


    def download(self, *pathes):
        for path in pathes:
            entry = self.tree[path]
            for op in entry.download():
                self.operations.add(op)


    def mirror(self, *pathes):
        for path in pathes:
            entry = self.tree[path]
            for op in entry.upload(clean=True):
                self.operations.add(op)


    def backup(self, *pathes):
        for path in pathes:
            entry = self.tree[path]
            for op in entry.download(clean=True):
                self.operations.add(op)


    def remove(self, *pathes):
        for path in pathes:
            entry = self.tree[path]
            for op in entry.remove():
                self.operations.add(op)


    def chmod(self, mode, *pathes):
        for path in pathes:
            entry = self.tree[path]
            for op in entry.chmod(mode):
                self.operations.add(op)


    def run(self):
        total = len(self.operations)
        for done, op in enumerate(self.operations):
            try:
                op(self.client)
            except Exception, e:
                self.log.warn(u"Échec de l'opération %s: %s", op, e)
        self.log.debug(u'Transfert terminé')


@command
class config(object):
    """Assistant de configuration des outils de mise en prod"""
    log = logging.getLogger('strass.config')

    class Required(Exception):
        pass

    def __init__(self, parser):
        pass

    def _prompt(self, config, section, name, label, default, prompt, prompter):
        while True:
            value = prompter(prompt)
            if value:
                break
            elif default:
                value = default
                break
            else:
                self.log.warn(u"Information requise !")

        config.set(section, name, value)
        return value


    def prompt_config_string(self, config, section, name, label):
        try:
            default = config.get(section, name)
            assert default
            prompt = "%s [%s] : " % (label, default)
        except Exception, e:
            default = None
            prompt = "%s : " % (label,)
        return self._prompt(config, section, name, label, default, prompt, raw_input)


    def prompt_config_password(self, config, section, name, label):
        try:
            default = config.get(section, name)
            assert default
            prompt = "%s [%s] : " % (label, 6 * '*')
        except Exception, e:
            default = None
            prompt = "%s : " % (label,)
        return self._prompt(config, section, name, label, default, prompt, getpass)


    def prompt_config(self, config, section):
        while 1:
            try:
                config.add_section(section)
            except Exception, e:
                pass
            self.prompt_config_string(config, section, 'hostname', "Serveur")
            self.prompt_config_string(config, section, 'username', "Identifiant")
            self.prompt_config_password(config, section, 'password', "Mot de passe")
            self.prompt_config_string(config, section, 'root', "Dossier")

            try:
                ftp = FTPManager()
                ftp.connect(config)
                is_saas = not ftp.exists('index.php') and ftp.exists('private/INSTALLED')
                config.set(section, 'saas', is_saas)
                break
            except Exception, e:
                self.log.error("Configuration incorrecte ?")
                self.log.error("%s", e)

        if is_saas:
            self.log.debug("Hébergement SaaS détecté")
        else:
            self.log.debug("Hébergement dédié détecté")


    def __call__(self, args, config):
        print """

Pour vous assister dans la maintenance de votre site, Strass a besoin
de connaître votre accès FTP.

"""
        section = 'remote'
        try:
            config.add_section(section)
            config.set(section, 'root', 'htdocs/')
        except Exception, e:
            pass

        try:
            self.prompt_config(config, section)
        except EOFError:
            return 1

        config.write(open(args.config, 'w'))
        os.chmod(args.config, 0600)
        self.log.info('Strass est prêt !')


@command
class setmaint(object):
    """Met le site distant en maintenance"""
    log = logging.getLogger('strass.maint')


    def __init__(self, parser):
        pass


    def __call__(self, args, config):
        ftp = FTPManager(local_root=args.root)
        ftp.connect(config)
        ftp.upload('maintenance.html')
        if not config.get('remote', 'saas'):
            ftp.upload('include/Strass.php', 'index.php')
        ftp.run()
        self.log.info("Site distant en mode maintenance")


@command
class unsetmaint(object):
    """Met le site distant en production"""
    log = logging.getLogger('strass.maint')


    def __init__(self, parser):
        pass


    def __call__(self, args, config):
        ftp = FTPManager(local_root=args.root)
        ftp.connect(config)
        ftp.remove('maintenance.html')
        ftp.run()
        self.log.info("Site distant réactivé")


@command
class backup(object):
    """Télécharge un site strass"""
    log = logging.getLogger('strass.backup')

    def __init__(self, parser):
        pass


    def __call__(self, args, config):
        ftp = FTPManager(local_root=args.root)
        ftp.connect(config)
        self.log.info("Préparation de la sauvegarde")
        ftp.backup('private/', 'data/')
        self.log.info(u"Démarrage de la sauvegarde")
        ftp.run()
        self.log.info(u"Site sauvegardé.")


@command
class upload(object):
    """Téléverse vers le site distant"""
    log = logging.getLogger('strass.mirror')


    def __init__(self, parser):
        parser.add_argument(
            '-p', '--partial',
            action='store_true', dest='partial',
            help="N'envoyer que le style et le code de strass, ne pas écraser les données.")


    def __call__(self, args, config):
        ftp = FTPManager(local_root=args.root)
        ftp.connect(config)
        self.log.info(u"Préparation de la mise à jour")
        ftp.mirror('500.html')
        ftp.chmod(0700, 'private/')
        if not args.saas:
            ftp.chmod(0700, 'include/')

        if args.partial:
            ftp.mirror('data/styles/')
            if not args.saas:
                ftp.mirror('index.php', 'include/Strass.php', 'include/Strass/', 'include/Wtk/',
                           'include/templates/', 'static/styles/')
        else:
            ftp.mirror('data/', 'private/', 'include/')
        # nettoyage
        ftp.remove('resources/', 'config/', 'cache/', 'data/private/')
        self.log.info(u"Démarrage de la mise à jour")
        ftp.run()
        self.log.info(u"Site distant mise à jour !")


if __name__ == '__main__':
    main = Script()
    sys.exit(main())
